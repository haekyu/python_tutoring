## 1. 함수 연습
- Factorial 함수를 구현해 보세요. 단! 재귀함수가 **아닌** 버전으로 구해보세요.
    - **input**: n
    - **output**: n!의 값

- n!은 다음과 같이 정의합니다.
    - n이 0보다 작거나 같은 경우: n! = 1
    - n이 0보다 큰 경우: n! = 1부터 n 까지의 곱

- 예) 
    ```python
    print(fac(0))
    print(fac(3))
    print(fac(5))
    ```
    출력 결과
    ```
    1
    6
    120
    ```

## 2. output 없는 함수
- Swap 함수를 구현해봅시다. 
    - **input**: 세 개의 인풋을 받습니다.
        - 어떤 list
        - index1
        - index2
    - **output**: 리턴하는 아웃풋은 없습니다! 아웃풋이 없는 함수도 있습니다!!
- 하는 일
    - 인풋으로 받은 리스트에서, 두 원소의 위치를 바꿉니다.
    - 바꿀 위치는 인풋으로 받은 두 인덱스입니다.
- 예)
    ```python
    lst = [0, 1, 2, 3, 4]
    swap(lst, 3, 0)
    print(lst)
    ```
    출력결과
    ```
    [3, 1, 2, 0, 4]
    ```
    잘 관찰해 보면, lst[3]과 lst[0]의 위치가 바뀌어 있음을 알 수 있습니다. 
- swap함수의 output은 딱히 없지만, 무언가 일을 하고 있음을 알 수 있습니다!
- output이 없는 함수를 void 함수라고 부르기도 합니다. void는 empty라는 뜻입니다.

## 3. 함수 연습
- rank 함수를 구현해 보세요.
    - **input**: 두 개의 list를 인풋으로 받습니다.
        - names: 학생들의 이름을 보관하는 리스트입니다.
        - scores: 각 학생들의 점수를 보관하는 리스트입니다. 모두 숫자입니다.
    - **output**: 
        - 각 학생들의 등수를 보관하는 리스트를 리턴합시다.
- 하는 일
    - 전체 학생들의 점수 / 등수 상황을 print 합니다.
        - 출력 형식은 '?번째 학생: 이름=?, 점수=?, 등수=?등' 입니다.
    - 마지막으로 전체 학생들의 등수를 보관하는 리스트를 리턴합니다.

- 예) 우리가 구현하는 함수를 get_ranks 라고 가정.
    ```python
    name_lst = ['이', '얼', '산', '쓰', '우']
    score_lst = [30, 42, 51, 18, 23]

    ranks = get_ranks(name_lst, score_lst)
    print('ranks:', ranks)
    ```
    출력 결과
    ```
    0번째 학생: 이름=이, 점수=30, 등수=3등
    1번째 학생: 이름=얼, 점수=42, 등수=2등
    2번째 학생: 이름=산, 점수=51, 등수=1등
    3번째 학생: 이름=쓰, 점수=18, 등수=5등
    4번째 학생: 이름=우, 점수=23, 등수=4등
    ranks: [3, 2, 1, 5, 4]
    ```
    
- 힌트) 학생 A의 등수는 "A의 점수보다 높은 다른 사람들의 명 수 + 1" 이 됩니다.

## 4. 재귀 함수
- permuation 함수를 만들어 봅시다.
    - **input**: 어떤 리스트
    - **output**: 어떤 리스트
- 하는 일
    - input으로 들어온 리스트의 원소들을 **줄 세우는 모든 가능한 방법**을 구하여, 그 방법들을 리스트로 모아 리턴한다.
- 주의 사항
    - 하나의 줄세우기 방법은 리스트로 표현한다. 예를 들어보자.
        - "a", "b", "c" 를 줄 세운다고 하자.
        - b c a 순으로 줄을 세웠다고 하면, 이 줄세우기는 ["b", "c", "a"] 라는 리스트로 표현된다.
    - output은 모든 줄세우기 방법을 리스트로 보관한다. 즉, output은 list의 (==줄세우기 방법의) list (==방법들의 모음집).
    - 모든 줄세우기 방법은 (인풋의 원소개수)! 개이다. (! == 팩토리얼)
- 예)
    ```python
    lst = ["a", "b", "c"]
    per_lst = get_permutation(lst)
    print(per_lst)
    ```
    출력 결과 (출력시 엔터는 내가 일부러 예쁘게 보여주려고 넣음)
    ```
    [['a', 'b', 'c'],
     ['a', 'c', 'b'],
     ['b', 'a', 'c'],
     ['b', 'c', 'a'],
     ['c', 'a', 'b'],
     ['c', 'b', 'a']]
    ```
- 힌트1) **재귀함수**를 이용하여 구현할 수 있다!
    - 초기 조건
        - 한 개의 원소를 나열하는 방법은 하나뿐이다.
        - 예를 들어, input이 ["a"] 라고 하자. "a"를 줄세우는 방법은 단 하나인 ["a"]뿐 이므로, output은 [["a"]] 이다.
    - 이후, 재귀를 통해.
        - 각 원소를 시작으로 하는 모든 방법을 차례로 구하면 된다.
            - 예를 들어, ["a", "b", "c", "d"] 가 input이면 
                - "a" 로 시작하는 모든 방법들 
                - "b" 로 시작하는 모든 방법들 
                - "c" 로 시작하는 모든 방법들 
                - "d" 로 시작하는 모든 방법들 
            - 을 구하여 모두 한 리스트에 집어 넣으면 된다.
        - 시작 원소가 정해진 경우, 모든 가능한 줄세우기 방법은 어떻게 구할 수 있을까?
            - 시작 원소를 뺀 나머지 원소들로 permutation 을 돌려 나머지 원소들의 줄세우기 방식들을 구한다.
            - 시작 원소와 위 나머지 줄세우기 결과들을 붙이면 된다.
        - 예) ["a", "b", "c"] 가 input이고 "a"가 시작원소인 경우
            - ["b", "c"] 로 얻을 수 있는 모든 줄세우기 방식을 **재귀 함수로** 알아낸 뒤, 그 방법들 앞에 "a"를 붙이면 된다.
            - 즉, ["b", "c"] 로 얻은 모든 줄세우기 방식이
                ```
                [['b', 'c'],
                 ['c', 'b']]
                ```
                라는 것을 알아낸 뒤 "a" 만 각 방법 앞에다 붙이면
            - "a" 로 시작하는 방법들은:
                ```
                [['a', 'b', 'c'],
                 ['a', 'c', 'b']]
                ```
                이렇게 된다.
            - 비슷한 방식으로 "b" 로 시작하는 방법들:
                ```
                [['b', 'a', 'c'],
                 ['b', 'c', 'a']]
                ```
            - 비슷한 방식으로 "c" 로 시작하는 방법들:
                ```
                [['c', 'a', 'b'],
                 ['c', 'b', 'a']]
                ```
            - 전체 방법은 `"a"로 시작하는 방법들 + "b"로 시작하는 방법들" + "c"로 시작하는 방법들` 이 된다.
- 힌트2) 아래와 같은 뼈대코드를 사용해도 됩니다.
```python
def get_permutation(lst):

    # 초기 조건
    if len(lst) == 1:
        # 아래 리턴 값은 두 개중에 하나이다. 둘 중에 맞는 것을 고르세요.
        # 1. lst
        # 2. [lst]
        return ???

    # 재귀
    else:
        # 모든 줄세우기의 방식을 all_permutations에 저장하여 후에 리턴할 예정!
        all_permutations = []

        # 각 start 원소에 대해
        for th, start in enumerate(lst):
            # start 원소를 제외한 나머지 원소들의 리스트를 구하자!
            # lst를 lst_except_start에 copy하고
            lst_except_start = lst[:] 
            # start를 lst_except_start에서 delete 한다.
            del lst_except_start[??]

            # start 원소를 뺀 나머지 원소들의 줄세우기 방법을 알아낸다.
            # 그 줄세우기 방식들을 tails 라고 부르자.
            tails = get_permutation(???)

            # tails 내의 각 줄세우기 방법인 tail에 대해서 
            # 각 tail 맨 앞에 start를 추가하면 
            # start로 시작하는 모든 줄세우기 방식을 구할 수 있다.
            for tail in tails:
                # start를 tail 맨앞에 추가 
                a_sequence_with_start = ???

                # 방금 구한 줄세우기 방식을 추가
                all_permutations.append(???)

        # 우리가 위에서 구했던 모든 줄세우기 방식을 리턴하자
        return ???
```
